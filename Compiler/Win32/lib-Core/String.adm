extern "kernel32.dll" __stdcall
{
	WideCharToMultiByte(
		CodePage, dwFlags, lpWideCharStr, cchWideChar,
		lpMultiByteStr, cchMultiByte, lpDefaultChar, lpUsedDefaultChar);
	MultiByteToWideChar(
		CodePage, dwFlags, lpMultiByteStr, cchMultiByte,
		lpWideCharStr, cchWideChar);
}

function memcpy(dest, src, count)
{
	if (dest <= src || dest >= src + count)
		__memcpy(dest, src, count);
	else
		__memcpy_rev(dest + count - 1, src + count - 1, count);
	return dest;
}

function memset(dest, c, count)
{
	__stosb(dest, c, count);
	return dest;
}

function cstr(s)
{
	var slen = lstrlen(s);
	var len = WideCharToMultiByte(0, 0, s, slen, null, null, null, null);
	var ret = new byte[len];
	WideCharToMultiByte(0, 0, s, slen, ret, ret.Length, null, null);
	return ret;
}

function wstr(s : byte[])
{
	var len = MultiByteToWideChar(0, 0, s, s.Length, null, null);
	var ret = string.Alloc(len);
	MultiByteToWideChar(0, 0, s, s.Length, ret, ret.Length);
	return ret;
}

function __string_equal(a : string, b : string)
{
	//printfln("%s([%d]\"%s\", [%d]\"%s\")", __FUNCTION__, a.Length, a, b.Length, b);
	var pa : char* = a;
	var pb : char* = b;
	if (pa == pb) return true;
	if (pa == null || pb == null || a.Length != b.Length) return false;
	
	for (int i = 0; i < a.Length; i++)
	{
		//printfln("%d: [%p]'%c', [%p]'%c'", i, pa, pa[0], pb, pb[0]);
		if (pa[0] != pb[0]) return false;
		pa++;
		pb++;
	}
	return true;
}

function __string_add(a : string, b : string)
{
	var ret = string.Alloc(a.Length + b.Length);
	if (a.Length > 0) __movsw(ret, a, a.Length);
	if (b.Length > 0) __movsw(addrof ret[a.Length], b, b.Length);
	//printfln("%s(%p:%s, %p:%s): %p:%s", __FUNCTION__, a, a, b, b, ret, ret);
	return ret;
}

function __string_add_char(a : string, b)
{
	var ret = string.Alloc(a.Length + 1);
	if (a.Length > 0) __movsw(ret, a, a.Length);
	__movsw(addrof ret[a.Length], addrof b, 1);
	return ret;
}

function __string_add_int(a : string, b)
{
	var bb = string.Format("%d", b);
	var ret = string.Alloc(a.Length + bb.Length);
	if (a.Length > 0) __movsw(ret, a, a.Length);
	__movsw(addrof ret[a.Length], bb, bb.Length);
	return ret;
}

function __string_mul_int(s : string, count)
{
	if (count < 1) return "";
	var ret = string.Alloc(s.Length * count);
	var p : char* = ret;
	for (int i = 0; i < count; i++)
	{
		__movsw(p, s, s.Length);
		p += s.Length;
	}
	return ret;
}

class string
{
	static function Alloc(length) : string
	{
		return __operator_new(typeof(string), sizeof(char), length, 0, 0);
	}
	
	static function Format(format : string, args : params)
	{
		return VFormat(format, args);
	}
	
	static function VFormat(format : string, args)
	{
		char buffer[1025];
		int len = wvsprintf(buffer, format, args);
		var ret = Alloc(len);
		if (len > 0) __movsw(ret, buffer, len);
		return ret;
	}
	
	static function IsNullOrEmpty(s : string)
	{
		return s == null || s.Length == 0;
	}
	
	function Substring(start, length) : string
	{
		if (start < 0) return null;
		int maxlen = this.Length - start;
		if (length > maxlen) length = maxlen;
		if (length < 0) length = 0;
		var ret = Alloc(length);
		//printfln("%s(%d, %d): %p, %p", __FUNCTION__, start, length, this, addrof this[start]);
		if (length > 0)
			__movsw(ret, addrof this[start], length);
		return ret;
	}
	
	function SubstringFrom(start) : string
	{
		if (start < 0) return null;
		return Substring(start, this.Length);
	}
	
	function StartsWith(s : string)
	{
		if (s == null) return false;
		return Substring(0, s.Length) == s;
	}
	
	function EndsWith(s : string)
	{
		if (s == null) return false;
		if (this.Length < s.Length) return false;
		return SubstringFrom(this.Length - s.Length) == s;
	}
	
	function ToLower() : string
	{
		var ret = Alloc(this.Length);
		var p : char* = ret;
		for (int i = 0; i < this.Length; i++)
		{
			char ch = this[i];
			if ('A' <= ch && ch <= 'Z') ch += 32;
			p[i] = ch;
		}
		return ret;
	}
	
	function ToUpper() : string
	{
		var ret = Alloc(this.Length);
		var p : char* = ret;
		for (int i = 0; i < this.Length; i++)
		{
			char ch = this[i];
			if ('a' <= ch && ch <= 'z') ch -= 32;
			p[i] = ch;
		}
		return ret;
	}
	
	function TrimStart() : string
	{
		int ps = 0;
		for (int i = 0; i < this.Length; i++)
		{
			ps = i;
			if (this[i] > ' ') break;
		}
		return SubstringFrom(ps);
	}
	
	function TrimEnd() : string
	{
		int pe = this.Length;
		for (int i = pe - 1; i >= 0; i--)
		{
			if (this[i] > ' ') break;
			pe = i;
		}
		return Substring(0, pe);
	}
	
	function Trim() : string
	{
		int ps = 0;
		for (int i = 0; i < this.Length; i++)
		{
			ps = i;
			if (this[i] > ' ') break;
		}
		int pe = this.Length;
		for (int i = pe - 1; i >= 0; i--)
		{
			if (this[i] > ' ') break;
			pe = i;
		}
		//printfln("%s(%s) => %d-%d", __FUNCTION__, this, ps, pe);
		return Substring(ps, pe - ps);
	}
	
	function Remove(start, length) : string
	{
		if (start < 0) return this;
		int maxlen = this.Length - start;
		if (length > maxlen) length = maxlen;
		if (length <= 0) return this;
		var ret = Alloc(this.Length - length);
		__movsw(ret, this, start);
		var pos = start + length;
		__movsw(addrof ret[start], addrof this[pos], this.Length - pos);
		return ret;
	}
	
	function RemoveFrom(start) : string
	{
		return Remove(start, this.Length - start);
	}
	
	function ToInt32() : int
	{
		int ret = 0;
		bool minus = false;
		bool first = true;
		for (int i = 0; i < this.Length; i++)
		{
			char ch = this[i];
			if (ch <= ' ')
				continue;
			else if (ch == '-' && first)
				minus = true;
			else if ('0' <= ch && ch <= '9')
			{
				ret *= 10;
				ret += ch - '0';
			}
			else
				break;
			first = false;
		}
		if (minus) ret = -ret;
		return ret;
	}
	
	function IndexWithLengthFrom(s : char*, length, start)
	{
		if (length < 1) return -1;
		int last = this.Length - length;
		for (int i = start; i <= last; i++)
		{
			if (this[i] == s[0])
			{
				var ok = true;
				for (int j = 1; j < length; j++)
				{
					if (this[i + j] != s[j])
					{
						ok = false;
						break;
					}
				}
				if (ok) return i;
			}
		}
		return -1;
	}
	
	function IndexFrom(s : string, start)
	{
		return IndexWithLengthFrom(s, s.Length, start);
	}
	
	function Index(s : string)
	{
		return IndexWithLengthFrom(s, s.Length, 0);
	}
	
	function IndexCharFrom(ch : char, start)
	{
		return IndexWithLengthFrom(addrof ch, 1, start);
	}
	
	function IndexChar(ch : char)
	{
		return IndexWithLengthFrom(addrof ch, 1, 0);
	}
	
	function LastIndexWithLengthFrom(s : char*, length, start)
	{
		if (length < 1) return -1;
		int last = this.Length - length;
		if (start > last) start = last;
		for (int i = start; i >= 0; i--)
		{
			if (this[i] == s[0])
			{
				var ok = true;
				for (int j = 1; j < length; j++)
				{
					if (this[i + j] != s[j])
					{
						ok = false;
						break;
					}
				}
				if (ok) return i;
			}
		}
		return -1;
	}
	
	function LastIndexFrom(s : string, start)
	{
		return LastIndexWithLengthFrom(s, s.Length, start);
	}
	
	function LastIndex(s : string)
	{
		return LastIndexWithLengthFrom(s, s.Length, this.Length);
	}
	
	function LastIndexCharFrom(ch : char, start)
	{
		return LastIndexWithLengthFrom(addrof ch, 1, start);
	}
	
	function LastIndexChar(ch : char)
	{
		return LastIndexWithLengthFrom(addrof ch, 1, this.Length);
	}
	
	function CountWithLength(s : char*, length)
	{
		if (length < 1) return 0;
		int ret = 0, last = this.Length - length;
		for (int i = 0; i <= last; i++)
		{
			if (this[i] == s[0])
			{
				var ok = true;
				for (int j = 1; j < length; j++)
				{
					if (this[i + j] != s[j])
					{
						ok = false;
						break;
					}
				}
				if (ok)
				{
					ret++;
					i += length - 1;
				}
			}
		}
		return ret;
	}
	
	function Count(s : string)
	{
		return CountWithLength(s, s.Length);
	}
	
	function CountChar(ch : char)
	{
		return CountWithLength(addrof ch, 1);
	}
	
	function Replace(before : string, after : string)
	{
		var count = Count(before);
		if (count == 0) return this;
		
		var len = this.Length + (after.Length - before.Length) * count;
		var ret = Alloc(len);
		var p : char* = ret;
		int last = this.Length - before.Length;
		for (int i = 0; i < this.Length; i++)
		{
			if (i <= last && this[i] == before[0])
			{
				var ok = true;
				for (int j = 1; j < before.Length; j++)
				{
					if (this[i + j] != before[j])
					{
						ok = false;
						break;
					}
				}
				if (ok)
				{
					__movsw(p, after, after.Length);
					p += after.Length;
					i += before.Length - 1;
					continue;
				}
			}
			p[0] = this[i];
			p++;
		}
		return ret;
	}
}
