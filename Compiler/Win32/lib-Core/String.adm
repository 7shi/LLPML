extern "kernel32.dll" __stdcall
{
	WideCharToMultiByte(
		CodePage, dwFlags, lpWideCharStr, cchWideChar,
		lpMultiByteStr, cchMultiByte, lpDefaultChar, lpUsedDefaultChar);
	MultiByteToWideChar(
		CodePage, dwFlags, lpMultiByteStr, cchMultiByte,
		lpWideCharStr, cchWideChar);
}

function memcpy(dest, src, count)
{
	if (dest <= src || dest >= src + count)
		__memcpy(dest, src, count);
	else
		__memcpy_rev(dest + count - 1, src + count - 1, count);
	return dest;
}

function memset(dest, c, count)
{
	__stosb(dest, c, count);
	return dest;
}

function cstr(s)
{
	var slen = lstrlen(s);
	var len = WideCharToMultiByte(0, 0, s, slen, null, null, null, null);
	var ret = new byte[len];
	WideCharToMultiByte(0, 0, s, slen, ret, ret.Length, null, null);
	return ret;
}

function wstr(s : byte[])
{
	var len = MultiByteToWideChar(0, 0, s, s.Length, null, null);
	var ret = string.Alloc(len);
	MultiByteToWideChar(0, 0, s, s.Length, ret, ret.Length);
	return ret;
}

function __string_equal(a : string, b : string)
{
	//printfln("%s([%d]\"%s\", [%d]\"%s\")", __FUNCTION__, a.Length, a, b.Length, b);
	var pa : char* = a;
	var pb : char* = b;
	if (pa == pb) return true;
	if (pa == null || pb == null || a.Length != b.Length) return false;
	
	for (int i = 0; i < a.Length; i++)
	{
		//printfln("%d: [%p]'%c', [%p]'%c'", i, pa, pa[0], pb, pb[0]);
		if (pa[0] != pb[0]) return false;
		pa++;
		pb++;
	}
	return true;
}

function __string_add(a : string, b : string) : string
{
	var ret = string.Alloc(a.Length + b.Length);
	if (a.Length > 0) __movsw(ret, a, a.Length);
	if (b.Length > 0) __movsw(addrof ret[a.Length], b, b.Length);
	//printfln("%s(%p:%s, %p:%s): %p:%s", __FUNCTION__, a, a, b, b, ret, ret);
	return ret;
}

function __string_add_char(a : string, b) : string
{
	var ret = string.Alloc(a.Length + 1);
	if (a.Length > 0) __movsw(ret, a, a.Length);
	__movsw(addrof ret[a.Length], addrof b, 1);
	return ret;
}

function __string_add_int(a : string, b) : string
{
	var bb = string.Format("%d", b);
	var ret = string.Alloc(a.Length + bb.Length);
	if (a.Length > 0) __movsw(ret, a, a.Length);
	__movsw(addrof ret[a.Length], bb, bb.Length);
	return ret;
}

class string
{
	static function Alloc(length) : string
	{
		return __operator_new(typeof(string), sizeof(char), length, 0, 0);
	}
	
	static function Format(format : string, args : params)
	{
		return VFormat(format, args);
	}
	
	static function VFormat(format : string, args)
	{
		char buffer[1025];
		int len = wvsprintf(buffer, format, args);
		var ret = Alloc(len);
		if (len > 0) __movsw(ret, buffer, len);
		return ret;
	}
	
	static function IsNullOrEmpty(s : string)
	{
		return s == null || s.Length == 0;
	}
	
	function Substring(start, length) : string
	{
		if (start < 0) return null;
		int maxlen = this.Length - start;
		if (length > maxlen) length = maxlen;
		if (length < 0) length = 0;
		var ret = Alloc(length);
		//printfln("%s(%d, %d): %p, %p", __FUNCTION__, start, length, this, addrof this[start]);
		if (length > 0)
			__movsw(ret, addrof this[start], length);
		return ret;
	}
	
	function SubstringFrom(start) : string
	{
		if (start < 0) return null;
		return Substring(start, this.Length);
	}
	
	function StartsWith(s : string)
	{
		if (s == null) return false;
		return Substring(0, s.Length) == s;
	}
	
	function EndsWith(s : string)
	{
		if (s == null) return false;
		if (this.Length < s.Length) return false;
		return SubstringFrom(this.Length - s.Length) == s;
	}
	
	function ToLower() : string
	{
		var ret = Alloc(this.Length);
		var p : char* = ret;
		for (int i = 0; i < this.Length; i++)
		{
			char ch = this[i];
			if ('A' <= ch && ch <= 'Z') ch += 32;
			p[i] = ch;
		}
		return ret;
	}
	
	function ToUpper() : string
	{
		var ret = Alloc(this.Length);
		var p : char* = ret;
		for (int i = 0; i < this.Length; i++)
		{
			char ch = this[i];
			if ('a' <= ch && ch <= 'z') ch -= 32;
			p[i] = ch;
		}
		return ret;
	}
	
	function TrimStart() : string
	{
		int ps = 0;
		for (int i = 0; i < this.Length; i++)
		{
			ps = i;
			if (this[i] > ' ') break;
		}
		return SubstringFrom(ps);
	}
	
	function TrimEnd() : string
	{
		int pe = this.Length;
		for (int i = pe - 1; i >= 0; i--)
		{
			if (this[i] > ' ') break;
			pe = i;
		}
		return Substring(0, pe);
	}
	
	function Trim() : string
	{
		int ps = 0;
		for (int i = 0; i < this.Length; i++)
		{
			ps = i;
			if (this[i] > ' ') break;
		}
		int pe = this.Length;
		for (int i = pe - 1; i >= 0; i--)
		{
			if (this[i] > ' ') break;
			pe = i;
		}
		//printfln("%s(%s) => %d-%d", __FUNCTION__, this, ps, pe);
		return Substring(ps, pe - ps);
	}
	
	function Remove(start, length) : string
	{
		if (start < 0) return this;
		int maxlen = this.Length - start;
		if (length > maxlen) length = maxlen;
		if (length <= 0) return this;
		var ret = Alloc(this.Length - length);
		__movsw(ret, this, start);
		var pos = start + length;
		__movsw(addrof ret[start], addrof this[pos], this.Length - pos);
		return ret;
	}
	
	function RemoveFrom(start) : string
	{
		return Remove(start, this.Length - start);
	}
}
