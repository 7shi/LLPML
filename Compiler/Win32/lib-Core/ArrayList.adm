struct ArrayList
{
	var Ptr : var*;
	int Count, Capacity;
	
	function ctor
	{
		Capacity = 16;
		Ptr = calloc(Capacity, sizeof(var));
		//Ptr = malloc(Capacity * sizeof(var));
		Count = 0;
	}
	
	function dtor
	{
		free(Ptr);
	}
	
	function Clear
	{
		Count = 0;
	}
	
	function Add(obj)
	{
		var cap = Capacity;
		while (Count >= Capacity)
			Capacity += Capacity;
		if (Capacity != cap)
		{
			var oldPtr = Ptr;
			Ptr = calloc(Capacity, sizeof(var));
			//Ptr = malloc(Capacity * sizeof(var));
			__movsd(Ptr, oldPtr, Count);
			free(oldPtr);
		}
		Ptr[Count++] = obj;
	}
	
	function Remove(obj)
	{
		var p : var* = Ptr;
		for (int i = 0; i < Count; i++)
		{
			if (p[0] == obj)
			{
				Count--;
				__movsd(p, p + 1, Count - i);
				return i;
			}
			p++;
		}
		return -1;
	}
	
	function RemoveAt(order)
	{
		if (order < 0 || order >= Count) return null;
		
		var ret = Ptr[order];
		var p : var* = addrof Ptr[order];
		Count--;
		__movsd(p, p + 1, Count - order);
		return ret;
	}
	
	function ForEach(delg)
	{
		for (int i = 0; i < Count; i++)
			delg(Ptr[i]);
	}
	
	function ForEachWithOrder(delg)
	{
		for (int i = 0; i < Count; i++)
			delg(Ptr[i], i);
	}
	
	function ForEachRev(delg)
	{
		for (int i = Count - 1; i >= 0; i--)
			delg(Ptr[i]);
	}
	
	function ForEachRevWithOrder(delg)
	{
		for (int i = Count - 1; i >= 0; i--)
			delg(Ptr[i], i);
	}
	
	function Find(item)
	{
		for (int i = 0; i < Count; i++)
		{
			var n = Ptr[i];
			if (n == item) return i;
		}
		return -1;
	}
	
	function FindLast(item)
	{
		for (int i = Count - 1; i >= 0; i--)
		{
			var n = Ptr[i];
			if (n == item) return i;
		}
		return -1;
	}
	
	function FindAll(dest : ArrayList, cond)
	{
		FindPartial(dest, 0, cond);
	}
	
	function FindPartial(dest : ArrayList, start, cond)
	{
		for (int i = start; i < Count; i++)
		{
			var n = Ptr[i];
			if (cond(n)) dest.Add(n);
		}
	}
}
